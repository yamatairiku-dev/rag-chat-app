# エラーハンドリング

このドキュメントでは、エラー処理とロギングについて説明します。

---

## エラーハンドリング戦略

### 基本方針
1. **予測可能なエラー**: 適切なエラーメッセージをユーザーに表示
2. **予測不可能なエラー**: ログに記録し、汎用エラーメッセージを表示
3. **ユーザー体験**: エラー時も適切なフィードバックを提供
4. **デバッグ**: 詳細なログでトラブルシューティングを容易に

---

## エラー分類

### 1. 認証エラー (1xxx)

| コード | 説明 | HTTPステータス | ユーザー表示 |
|-------|------|---------------|-------------|
| 1001 | トークン無効 | 401 | 再ログインしてください |
| 1002 | トークン期限切れ | 401 | セッションが切れました |
| 1004 | 所属コード未設定 | 403 | アクセス権限がありません |
| 1005 | セッション期限切れ | 401 | セッションが切れました |

### 2. Graph APIエラー (1xxx)

| コード | 説明 | HTTPステータス | ユーザー表示 |
|-------|------|---------------|-------------|
| 1100 | Graph API一般エラー | 500 | システムエラーが発生しました |
| 1101 | ユーザー情報取得失敗 | 404 | ユーザー情報が見つかりません |

### 3. Dify APIエラー (2xxx)

| コード | 説明 | HTTPステータス | ユーザー表示 |
|-------|------|---------------|-------------|
| 2001 | 接続失敗 | 503 | サービスに接続できません |
| 2002 | タイムアウト | 504 | リクエストがタイムアウトしました |
| 2003 | 不正なレスポンス | 500 | システムエラーが発生しました |
| 2004 | API一般エラー | 500 | システムエラーが発生しました |

### 4. バリデーションエラー (3xxx)

| コード | 説明 | HTTPステータス | ユーザー表示 |
|-------|------|---------------|-------------|
| 3001 | メッセージ空 | 400 | メッセージを入力してください |
| 3002 | メッセージ長すぎ | 400 | メッセージが長すぎます |

### 5. レートリミット (4xxx)

| コード | 説明 | HTTPステータス | ユーザー表示 |
|-------|------|---------------|-------------|
| 4001 | レート制限超過 | 429 | リクエストが多すぎます |

---

## エラーハンドラー実装

### グローバルエラーハンドラー

```typescript
// app/lib/errors/error-handler.ts
import { json } from 'react-router';
import { AppError, ErrorCode } from '~/types/error';
import { logger } from '~/lib/logging/logger';

/**
 * グローバルエラーハンドラー
 */
export function handleError(error: unknown) {
  // AppErrorの場合
  if (error instanceof AppError) {
    logger.error('Application Error', {
      code: error.code,
      message: error.message,
      statusCode: error.statusCode,
      stack: error.stack,
    });
    
    return json(
      {
        error: {
          code: error.code,
          message: error.message,
        },
        timestamp: Date.now(),
      },
      { status: error.statusCode }
    );
  }
  
  // 通常のErrorの場合
  if (error instanceof Error) {
    logger.error('Unexpected Error', {
      message: error.message,
      stack: error.stack,
    });
    
    return json(
      {
        error: {
          code: ErrorCode.INTERNAL_SERVER_ERROR,
          message: 'システムエラーが発生しました',
        },
        timestamp: Date.now(),
      },
      { status: 500 }
    );
  }
  
  // その他のエラー
  logger.error('Unknown Error', { error });
  
  return json(
    {
      error: {
        code: ErrorCode.INTERNAL_SERVER_ERROR,
        message: 'システムエラーが発生しました',
      },
      timestamp: Date.now(),
    },
    { status: 500 }
  );
}
```

### React Routerエラーバウンダリ

```typescript
// app/root.tsx
import { isRouteErrorResponse, useRouteError } from 'react-router';

export function ErrorBoundary() {
  const error = useRouteError();
  
  if (isRouteErrorResponse(error)) {
    return (
      <div className="error-page">
        <h1>{error.status} {error.statusText}</h1>
        <p>{error.data?.message || 'エラーが発生しました'}</p>
      </div>
    );
  }
  
  if (error instanceof Error) {
    return (
      <div className="error-page">
        <h1>エラーが発生しました</h1>
        <p>しばらくしてからもう一度お試しください</p>
      </div>
    );
  }
  
  return (
    <div className="error-page">
      <h1>予期しないエラーが発生しました</h1>
    </div>
  );
}
```

---

## ロギング実装

### ロガー設定

```typescript
// app/lib/logging/logger.ts
import winston from 'winston';
import { env } from '~/lib/utils/env';

/**
 * ログフォーマッター
 */
const logFormat = winston.format.combine(
  winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
  winston.format.errors({ stack: true }),
  winston.format.json()
);

/**
 * ロガーインスタンス
 */
export const logger = winston.createLogger({
  level: env.LOG_LEVEL,
  format: logFormat,
  defaultMeta: { service: 'rag-chat-app' },
  transports: [
    // ファイル出力
    new winston.transports.File({
      filename: `${env.LOG_DIRECTORY}/error.log`,
      level: 'error',
      maxsize: 10485760, // 10MB
      maxFiles: env.LOG_MAX_FILES,
    }),
    new winston.transports.File({
      filename: `${env.LOG_DIRECTORY}/combined.log`,
      maxsize: 10485760, // 10MB
      maxFiles: env.LOG_MAX_FILES,
    }),
  ],
});

// 開発環境ではコンソールにも出力
if (env.NODE_ENV === 'development') {
  logger.add(
    new winston.transports.Console({
      format: winston.format.combine(
        winston.format.colorize(),
        winston.format.simple()
      ),
    })
  );
}
```

### ログ使用例

```typescript
// 情報ログ
logger.info('User logged in', {
  userId: session.userId,
  email: session.userEmail,
  departmentCode: session.departmentCode,
});

// 警告ログ
logger.warn('Token refresh failed', {
  userId: session.userId,
  error: error.message,
});

// エラーログ
logger.error('Dify API Error', {
  userId: session.userId,
  query: request.query,
  error: error.message,
  stack: error.stack,
});

// デバッグログ
logger.debug('Session created', {
  sessionId,
  userId: session.userId,
  expiresAt: session.tokenExpiresAt,
});
```

---

## エラー回復戦略

### 1. リトライ処理

```typescript
// app/lib/utils/retry.ts
export async function withRetry<T>(
  fn: () => Promise<T>,
  options: {
    maxRetries: number;
    baseDelay: number;
    maxDelay: number;
    backoffMultiplier: number;
  }
): Promise<T> {
  let lastError: Error;
  
  for (let attempt = 0; attempt <= options.maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error as Error;
      
      if (attempt < options.maxRetries) {
        const delay = Math.min(
          options.baseDelay * Math.pow(options.backoffMultiplier, attempt),
          options.maxDelay
        );
        
        logger.warn(`Retry attempt ${attempt + 1} after ${delay}ms`, {
          error: lastError.message,
        });
        
        await sleep(delay);
      }
    }
  }
  
  throw lastError!;
}

function sleep(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}
```

### 2. サーキットブレーカー（将来実装）

```typescript
// 連続失敗時にAPIコールを一時停止
class CircuitBreaker {
  private failures = 0;
  private state: 'closed' | 'open' | 'half-open' = 'closed';
  
  async execute<T>(fn: () => Promise<T>): Promise<T> {
    if (this.state === 'open') {
      throw new Error('Circuit breaker is open');
    }
    
    try {
      const result = await fn();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }
  
  private onSuccess() {
    this.failures = 0;
    this.state = 'closed';
  }
  
  private onFailure() {
    this.failures++;
    if (this.failures >= 5) {
      this.state = 'open';
      // 30秒後に half-open に移行
      setTimeout(() => {
        this.state = 'half-open';
      }, 30000);
    }
  }
}
```

---

## ユーザーへのエラー表示

### トースト通知コンポーネント

```typescript
// app/components/ui/toast.tsx
import { useEffect, useState } from 'react';

export function Toast({ 
  message, 
  type = 'error',
  duration = 5000 
}: {
  message: string;
  type?: 'error' | 'success' | 'warning';
  duration?: number;
}) {
  const [visible, setVisible] = useState(true);
  
  useEffect(() => {
    const timer = setTimeout(() => {
      setVisible(false);
    }, duration);
    
    return () => clearTimeout(timer);
  }, [duration]);
  
  if (!visible) return null;
  
  return (
    <div className={`toast toast-${type}`}>
      <p>{message}</p>
      <button onClick={() => setVisible(false)}>×</button>
    </div>
  );
}
```

---

## モニタリング（将来実装）

### Azure Application Insights連携

```typescript
// app/lib/monitoring/app-insights.ts
import { ApplicationInsights } from '@microsoft/applicationinsights-web';

const appInsights = new ApplicationInsights({
  config: {
    instrumentationKey: process.env.APPINSIGHTS_INSTRUMENTATION_KEY,
    enableAutoRouteTracking: true,
  },
});

appInsights.loadAppInsights();

export { appInsights };
```

---

**関連ドキュメント:**
- [型定義](./07_型定義.md)
- [API仕様](./03_API仕様.md)
- [実装チェックリスト](./12_チェックリスト.md)

**最終更新**: 2025年11月
