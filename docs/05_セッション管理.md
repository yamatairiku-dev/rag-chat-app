# セッション管理

このドキュメントでは、ユーザーセッションの管理方法について説明します。

---

## セッション管理の概要

### 設計方針
- **サーバーサイドセッション**: セッションデータはサーバーで管理
- **Secure Cookie**: セッションIDのみクライアントに送信
- **トークン管理**: Access Token / Refresh Tokenをセッションに保存
- **自動更新**: トークン期限切れ時の自動リフレッシュ

---

## セッションストレージ

### メモリストレージ（開発・MVP用）

```typescript
// app/lib/session/memory-storage.ts
import type { UserSession, SessionStorage } from '~/types/session';

class MemorySessionStorage implements SessionStorage {
  private sessions: Map<string, UserSession> = new Map();

  async get(sessionId: string): Promise<UserSession | null> {
    return this.sessions.get(sessionId) || null;
  }

  async set(sessionId: string, session: UserSession): Promise<void> {
    this.sessions.set(sessionId, session);
  }

  async delete(sessionId: string): Promise<void> {
    this.sessions.delete(sessionId);
  }

  async exists(sessionId: string): Promise<boolean> {
    return this.sessions.has(sessionId);
  }
  
  // 定期的なクリーンアップ
  async cleanup(): Promise<void> {
    const now = Date.now();
    for (const [sessionId, session] of this.sessions.entries()) {
      // 24時間以上アクセスがないセッションを削除
      if (now - session.lastAccessedAt > 86400000) {
        this.sessions.delete(sessionId);
      }
    }
  }
}

export const memoryStorage = new MemorySessionStorage();
```

### Redisストレージ（本番環境用・将来実装）

```typescript
// app/lib/session/redis-storage.ts
import { createClient } from 'redis';
import type { UserSession, SessionStorage } from '~/types/session';
import { env } from '~/lib/utils/env';

class RedisSessionStorage implements SessionStorage {
  private client = createClient({
    url: env.REDIS_URL,
  });

  constructor() {
    this.client.connect();
  }

  async get(sessionId: string): Promise<UserSession | null> {
    const data = await this.client.get(`session:${sessionId}`);
    return data ? JSON.parse(data) : null;
  }

  async set(sessionId: string, session: UserSession): Promise<void> {
    await this.client.set(
      `session:${sessionId}`,
      JSON.stringify(session),
      { EX: env.SESSION_MAX_AGE / 1000 } // 秒単位
    );
  }

  async delete(sessionId: string): Promise<void> {
    await this.client.del(`session:${sessionId}`);
  }

  async exists(sessionId: string): Promise<boolean> {
    return (await this.client.exists(`session:${sessionId}`)) === 1;
  }
}

export const redisStorage = new RedisSessionStorage();
```

---

## セッションマネージャー

```typescript
// app/lib/session/session-manager.ts
import { randomBytes, createHmac } from 'crypto';
import type { UserSession } from '~/types/session';
import { env } from '~/lib/utils/env';
import { memoryStorage } from './memory-storage';
// import { redisStorage } from './redis-storage'; // 将来的に

const storage = env.SESSION_STORAGE === 'redis' 
  ? redisStorage  // 将来的に実装
  : memoryStorage;

/**
 * セッションIDを生成
 */
function generateSessionId(): string {
  return randomBytes(32).toString('hex');
}

/**
 * セッションIDに署名を追加
 */
function signSessionId(sessionId: string): string {
  const signature = createHmac('sha256', env.SESSION_SECRET)
    .update(sessionId)
    .digest('hex');
  return `${sessionId}.${signature}`;
}

/**
 * 署名を検証
 */
function verifySessionId(signedSessionId: string): string | null {
  const [sessionId, signature] = signedSessionId.split('.');
  
  if (!sessionId || !signature) {
    return null;
  }
  
  const expectedSignature = createHmac('sha256', env.SESSION_SECRET)
    .update(sessionId)
    .digest('hex');
  
  if (signature !== expectedSignature) {
    return null;
  }
  
  return sessionId;
}

/**
 * セッション作成
 */
export async function createSession(
  sessionData: Omit<UserSession, 'createdAt' | 'lastAccessedAt'>
): Promise<{ cookie: string; sessionId: string }> {
  const sessionId = generateSessionId();
  const now = Date.now();
  
  const session: UserSession = {
    ...sessionData,
    createdAt: now,
    lastAccessedAt: now,
  };
  
  await storage.set(sessionId, session);
  
  const signedSessionId = signSessionId(sessionId);
  const cookie = createSessionCookie(signedSessionId);
  
  return { cookie, sessionId };
}

/**
 * セッション取得
 */
export async function getSession(request: Request): Promise<UserSession | null> {
  const cookies = request.headers.get('Cookie');
  if (!cookies) {
    return null;
  }
  
  const signedSessionId = parseCookie(cookies, 'session');
  if (!signedSessionId) {
    return null;
  }
  
  const sessionId = verifySessionId(signedSessionId);
  if (!sessionId) {
    return null;
  }
  
  const session = await storage.get(sessionId);
  if (!session) {
    return null;
  }
  
  // セッション期限確認
  if (Date.now() - session.createdAt > env.SESSION_MAX_AGE) {
    await storage.delete(sessionId);
    return null;
  }
  
  // 最終アクセス日時を更新
  session.lastAccessedAt = Date.now();
  await storage.set(sessionId, session);
  
  return session;
}

/**
 * セッション削除
 */
export async function deleteSession(request: Request): Promise<string> {
  const cookies = request.headers.get('Cookie');
  if (!cookies) {
    return createClearSessionCookie();
  }
  
  const signedSessionId = parseCookie(cookies, 'session');
  if (!signedSessionId) {
    return createClearSessionCookie();
  }
  
  const sessionId = verifySessionId(signedSessionId);
  if (sessionId) {
    await storage.delete(sessionId);
  }
  
  return createClearSessionCookie();
}

/**
 * セッションCookie作成
 */
function createSessionCookie(signedSessionId: string): string {
  const maxAge = env.SESSION_MAX_AGE / 1000; // 秒単位
  
  return [
    `session=${signedSessionId}`,
    `Max-Age=${maxAge}`,
    'Path=/',
    env.COOKIE_SECURE ? 'Secure' : '',
    env.COOKIE_HTTP_ONLY ? 'HttpOnly' : '',
    `SameSite=${env.COOKIE_SAME_SITE}`,
    env.COOKIE_DOMAIN ? `Domain=${env.COOKIE_DOMAIN}` : '',
  ]
    .filter(Boolean)
    .join('; ');
}

/**
 * セッションCookieクリア
 */
function createClearSessionCookie(): string {
  return [
    'session=',
    'Max-Age=0',
    'Path=/',
    env.COOKIE_SECURE ? 'Secure' : '',
    env.COOKIE_HTTP_ONLY ? 'HttpOnly' : '',
    `SameSite=${env.COOKIE_SAME_SITE}`,
  ]
    .filter(Boolean)
    .join('; ');
}

/**
 * Cookieパース
 */
function parseCookie(cookieHeader: string, name: string): string | null {
  const cookies = cookieHeader.split(';');
  
  for (const cookie of cookies) {
    const [cookieName, cookieValue] = cookie.trim().split('=');
    if (cookieName === name) {
      return cookieValue;
    }
  }
  
  return null;
}

/**
 * セッション必須チェック（React Router用）
 */
export async function requireUserSession(request: Request): Promise<UserSession> {
  const session = await getSession(request);
  
  if (!session) {
    throw redirect('/login');
  }
  
  return session;
}
```

---

## トークン自動更新

```typescript
// app/lib/session/token-refresh.ts
import { refreshAccessToken } from '~/lib/auth/entra-client';
import type { UserSession } from '~/types/session';
import { memoryStorage } from './memory-storage';

/**
 * トークン期限確認と自動更新
 */
export async function ensureValidToken(
  sessionId: string,
  session: UserSession
): Promise<UserSession> {
  const now = Date.now();
  const buffer = 5 * 60 * 1000; // 5分のバッファ
  
  // トークンが期限切れ、または5分以内に期限切れ
  if (now + buffer >= session.tokenExpiresAt) {
    if (!session.refreshToken) {
      throw new Error('Refresh token not available');
    }
    
    try {
      // リフレッシュトークンで新しいアクセストークンを取得
      const tokens = await refreshAccessToken(session.refreshToken);
      
      // セッションを更新
      const updatedSession: UserSession = {
        ...session,
        accessToken: tokens.accessToken,
        refreshToken: tokens.refreshToken,
        tokenExpiresAt: Date.now() + tokens.expiresIn * 1000,
        lastAccessedAt: Date.now(),
      };
      
      await memoryStorage.set(sessionId, updatedSession);
      
      return updatedSession;
    } catch (error) {
      // リフレッシュ失敗 → セッション削除
      await memoryStorage.delete(sessionId);
      throw new Error('Failed to refresh token');
    }
  }
  
  return session;
}
```

---

## セッション定期クリーンアップ

```typescript
// app/lib/session/cleanup.ts
import { memoryStorage } from './memory-storage';

/**
 * 定期的なセッションクリーンアップ
 */
export function startSessionCleanup(): void {
  // 1時間ごとにクリーンアップ
  setInterval(async () => {
    await memoryStorage.cleanup();
    console.log('[Session Cleanup] Expired sessions removed');
  }, 3600000); // 1時間
}
```

---

## セキュリティ考慮事項

### 1. セッションID
- 暗号学的に安全な乱数生成 (`crypto.randomBytes`)
- HMAC署名による改ざん防止
- 推測不可能な長さ（64文字以上）

### 2. Cookie設定
- **Secure**: HTTPS通信のみ
- **HttpOnly**: JavaScriptからアクセス不可
- **SameSite**: CSRF対策 (Lax推奨)

### 3. セッション有効期限
- デフォルト: 24時間
- 最終アクセスから24時間で自動削除
- トークンは期限前に自動更新

### 4. トークン管理
- アクセストークン: セッションに保存、クライアントに送信しない
- リフレッシュトークン: セッションに安全に保存
- 期限切れ前の自動更新

---

**関連ドキュメント:**
- [認証設計](./04_認証設計.md)
- [環境変数設定](./02_環境変数設定.md)
- [実装ガイド Phase 1](./08_実装ガイド_Phase1.md)

**最終更新**: 2025年11月
